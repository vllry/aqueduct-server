#!/usr/bin/python3

from bottle import route, run, request
import json
from os import getuid, mkdir, path
import shutil
from sys import argv
from threading import Thread

from aqueductbuilderinterface import queue_tasks
import aqueductdatabase as db
from libaqueduct import GPG
import libaqueductserver as aqueduct



conf = aqueduct.Config()
gpg = GPG('Aqueduct Server', conf.general['dir']['gpg'], True)
if len(argv) > 1:
	if len(argv) == 3 and argv[1] == '--import-user-key':
		keyid = gpg.import_key_file(argv[2])
		db.add_user_key(keyid)
	else:
		print('Invalid parameters')



@route('/', method='GET')
def get_info():
	info = {
		'service': 'aqueduct-server',
		'version': conf.general['version']
		}
	return json.dumps(info)



@route('/pubkey', method='GET')
def get_info():
	return gpg.export()



@route('/callback', method='POST')
def handle_callback():
	jobid = request.forms.get('jobid')
	arch = request.forms.get('arch')
	operatingsystem = request.forms.get('os')
	release = request.forms.get('release')
	success = request.forms.get('success')
	location = request.forms.get('location')
	if not (jobid and arch and operatingsystem and release and success and location):
		return {'success':False, 'message':'Missing parameters'}

	if success == '1':
		task_done(jobid, arch, operatingsystem, release)
	else:
		task_failed(jobid, arch, operatingsystem, release)

	return {'success': True, 'message': 'Callback recieved'}



@route('/submit', method='POST')
def build_submit():
	signature = request.forms.get('signature')
	upload = request.files.data

	if not upload or not upload.file:
		return {'success': False, 'message': 'No file supplied'}
	if not signature:
		return {'success': False, 'message': 'No signature supplied'}

	jobid = db.add_job()
	working_dir = conf.general['dir']['intake']+str(jobid)+'/'
	mkdir(working_dir)
	upload.save(working_dir)
	f = open(working_dir + 'upload.asc', 'w')
	f.write(signature)
	f.close()
	conf.print('info', 'New package submitted, given jobid %s' % (jobid))

	if gpg.decrypt_and_verify_file(working_dir+upload.filename, working_dir+'upload.asc', working_dir+'upload.tar.gz'):
		t = Thread(target=intake, args=(conf,jobid,working_dir+'upload.tar.gz'))
		t.start()
		return {
			'success': True,
			'message': 'Source submitted'
		}
	else:
		conf.print('warn', "Upload for jobid %s rejected due to signature" % (jobid))
		return {
			'success': False,
			'message': 'Signature is invalid, or not from a permitted uploader.'
		}


#Bottle routes above here
#Regular functions below here


def task_done(jobid, arch, os, release):
	db.task_done(jobid, arch, os, release)
	#Check if job is done
	conf.print('info', "Task for jobid %s done" % (jobid))


def task_failed(jobid, arch, os, release):
	db.task_failed(jobid, arch, os, release)
	#Send error
	conf.print('info', "Task for jobid %s failed!" % (jobid))


def intake(conf, jobid, filepath):
	dir_processing = conf.general['dir']['processing'] + str(jobid) + '/'
	conf.print('debug', 'Processing package in ' + dir_processing)
	dir_processing_orig = dir_processing + 'original/'

	name = aqueduct.untar(filepath, dir_processing_orig)
	dir_processing_orig += name + '/'
	if path.isfile(dir_processing_orig):
		conf.print('warn', "Tarfile did not have valid contents")
		return
	Aqueduct = aqueduct.json_file(dir_processing_orig+'debian/Aqueduct')

	if Aqueduct['version'] < 1:
		builds = []
		for operatingsystem in Aqueduct['oses']:
			var_dictionary = {'os' : operatingsystem}
			releases = aqueduct.replace(Aqueduct['oses'][operatingsystem]['releases'].replace(' ',''), conf.repos[operatingsystem]['alliases']).split(',')

			for release in releases:
				var_dictionary['release'] = release

				#Modify the source for this particular os/release
				shutil.copytree(dir_processing_orig, '%s%s/%s' % (dir_processing, operatingsystem, release))
				target_dir = "%s%s/%s/" % (dir_processing, operatingsystem, release)
				aqueduct.package_modify(Aqueduct, target_dir, var_dictionary)

				arches = []
				f = open(target_dir+'debian/control', 'r')
				control = f.read().split('\n')
				for line in control:
					if line.startswith('Architecture'):
						line = line.split(':', 1)[-1].replace(' ', '')
						if line == 'any':
							arches = conf.repos[operatingsystem][release]['arches']
							try:
								arches.remove('source')
							except ValueError:
								pass
						else:
							arches = line.split(',')
						break
				f.close()

				for arch in arches:
					conf.print('info', "Adding build for arch %s, os %s, release %s" % (arch, operatingsystem, release))
					builds.append({'arch':arch, 'os':operatingsystem, 'release':release})

		for b in range(0,len(builds)):
			builds[b]['jobid'] = jobid
		db.add_tasks_to_job(builds, jobid)
		queue_tasks(builds)	

	else:
		conf.print('error', "Unrecognized aqueduct version: " + Aqueduct['version'])





if getuid() == 0:
	db.mark_all_builders_offline()
	run(host='', port=conf.general['port'], debug=True)
else:
	conf.print('error', 'Please run aqueduct-server as root')
